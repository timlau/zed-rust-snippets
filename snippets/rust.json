{
  "add async function/method": {
    "prefix": "1u-add-fn-async",
    "description": "add async function/method",
    "body": [
      "async fn ${1:myfunc}(${2:value}: ${3:String}) -> ${4:String} {",
      "\t${5:todo!();}",
      "}",
      "\n"
    ]
  },
  "add function/method": {
    "prefix": "1u-add-fn",
    "description": "add function/method",
    "body": [
      "fn ${1:myfunc}(${2:value}: ${3:String}) -> ${4:String} {",
      "\t${5:todo!();}",
      "}",
      "\n"
    ]
  },
  "add pub async function/method": {
    "prefix": "1u-add-fn-pub-async",
    "description": "add pub async function/method",
    "body": [
      "pub async fn ${1:myfunc}(${2:value}: ${3:String}) -> ${4:String} {",
      "\t${5:todo!();}",
      "}",
      "\n"
    ]
  },
  "add pub function/method": {
    "prefix": "1u-add-fn-pub",
    "description": "add pub function/method",
    "body": [
      "pub fn ${1:myfunc}(${2:value}: ${3:String}) -> ${4:String} {",
      "\t${5:todo!();}",
      "}",
      "\n"
    ]
  },
  "ssync main fn() ": {
    "prefix": "1u-fn-main-async",
    "description": "async main fn returning Result",
    "body": [
      "#[tokio::main]",
      "async fn main() -> Result<()> {",
      "\t${2}println!(\"Hello, world!\");",
      "",
      "\tOk(())",
      "}",
      ""
    ]
  },
  "main fn": {
    "prefix": "1u-fn-main-result",
    "description": "main fn returning Result",
    "body": [
      "fn main() -> Result<()> {",
      "\t${2}println!(\"Hello, world!\");",
      "",
      "\tOk(())",
      "}",
      ""
    ]
  },
  "for loop": {
    "prefix": "1u-for",
    "description": "for loop",
    "body": ["for ${1:elem} in ${2:iter} {", "\t$0", "}"]
  },
  "HashMap Entry": {
    "prefix": "1u-hashmap-entry",
    "description": "append value to vector in hashmap",
    "body": ["${1:map}.entry(${2:key}).or_default().push(${3:value});"]
  },
  "HashMap <String, Vec<String>>": {
    "prefix": "1u-hashmap-string-vec",
    "description": "define HashMap <T, Vec<U>>",
    "body": [
      "let mut ${1:map}: HashMap<${2:String}, Vec<${3:String}>> = HashMap::new();"
    ]
  },
  "if let some": {
    "prefix": "1u-if-some",
    "description": "if let Some pattern matching",
    "body": ["if let Some(${1:value}) = ${2:option} {", "  $3", "}"]
  },
  "impl default method": {
    "prefix": "1u-impl-default",
    "description": "implement default() method for struct",
    "body": [
      "impl ${1:MyStrunc} {",
      "\tpub fn default() -> Self {",
      "\t\tSelf {",
      "\t\t\t${2}",
      "\t\t}",
      "\t}",
      "}",
      "\n"
    ]
  },
  "impl From": {
    "prefix": "1u-impl-from",
    "description": "impl From implementation for struct",
    "body": [
      "impl From<${1:from_type}> for ${2:MyStruct} {",
      "\tfn from(val: ${1}) -> Self {",
      "\t\t$3",
      "\t}",
      "}",
      "\n"
    ]
  },
  "impl struct method": {
    "prefix": "1u-impl-method",
    "description": "impl method for struct",
    "body": [
      "impl ${1:MyStrunc} {",
      "\tpub fn ${2:my_method}(${3}) -> ${4:()} {",
      "\t\t${5:todo!();}",
      "\t}",
      "}",
      "\n"
    ]
  },
  "impl new method": {
    "prefix": "1u-impl-new",
    "description": "impl new method for struct",
    "body": [
      "impl ${1:MyStrunc} {",
      "\tpub fn new(${2:value}: ${3:String}) -> Self {",
      "\t\tSelf {",
      "\t\t\t${4}",
      "\t\t}",
      "\t}",
      "}",
      "\n"
    ]
  },
  "impl TryFrom": {
    "prefix": "1u-impl-try-from",
    "description": "impl TryFrom for struct (assume Result<T> in scope)",
    "body": [
      "impl TryFrom<${1:FromType}> for ${2:MyStruct} {",
      "\ttype Error = ${3:Error};",
      "\tfn try_from(val: ${1}) -> Result<${2}> {",
      "\t\t$4",
      "\t}",
      "}",
      "\n"
    ]
  },
  "macro_rules": {
    "prefix": "1u-macro-rules",
    "description": "define macro_rules!",
    "body": [
      "macro_rules! ${1:my_macro} {",
      "\t($2) => {",
      "\t\t$0",
      "\t};",
      "}"
    ]
  },
  "Match an option": {
    "prefix": "1u-match-option",
    "description": "match an option statement",
    "body": [
      "match ${1:option} {",
      "  Some(value) => { $2 }",
      "  None => { $3 }",
      "}"
    ]
  },
  "Match a result": {
    "prefix": "1u-match-result",
    "description": "match a result statement",
    "body": [
      "match ${1:result} {",
      "\tOk(value) => { $2 }",
      "\tErr(error) => { $3 }",
      "}"
    ]
  },
  "async test-function": {
    "prefix": "1u-test-fn-async",
    "description": "async test function",
    "body": [
      "#[tokio::test]",
      "async fn test_${1:name}() -> Result<()> {",
      "\t${2}",
      "",
      "\t\tOk(())",
      "}",
      "\n"
    ]
  },
  "test-function": {
    "prefix": "1u-test-fn",
    "description": "test function",
    "body": [
      "#[test]",
      "fn test_${1:name}() -> Result<()> {",
      "\t\t${2:todo!();}",
      "",
      "\t\tOk(())",
      "}",
      "\n"
    ]
  },
  "test-module": {
    "prefix": "1u-test-module",
    "description": "test module boilerplate",
    "body": [
      "",
      "#[cfg(test)]",
      "mod tests {",
      "\ttype Result<T> = core::result::Result<T, Box<dyn std::error::Error>>; // For tests.",
      "",
      "\tuse super::*;",
      "",
      "\t$1",
      "}",
      ""
    ]
  },
  "to_string()": {
    "prefix": "1u-to-string",
    "description": ".to_string()",
    "body": ["to_string()"]
  },
  "use module::{}": {
    "prefix": "1u-use-1",
    "description": "use <module>::<imports>",
    "body": ["use ${1:module}::{${3:import}};\n"]
  },
  "use std::module::{}": {
    "prefix": "1u-use-2",
    "description": "use <module>::<sub-module>::<imports>",
    "body": ["use ${1:std}::${2:submodule}::{${3:import}};"]
  },
  "Derive": {
    "prefix": "1u-dbg-derive",
    "description": "#[derive(<traits>)]",
    "body": ["#[derive(Debug,${1})]"]
  },
  "Derive traits": {
    "prefix": "1u-dbg-derive-plus",
    "description": "#[derive(Debug, <traits>)]",
    "body": ["#[derive(Debug,${1})]\n"]
  },
  "Debug enum": {
    "prefix": "1u-dbg-enum",
    "description": "enum with Debug derive",
    "body": [
      "#[derive(Debug)]",
      "enum ${1:Name} {",
      "  ${2:Variant1},",
      "  ${3:Variant2},",
      "}",
      "\n"
    ]
  },
  "Debug struct": {
    "prefix": "1u-dbg-struct",
    "description": "struct with Debug derive",
    "body": [
      "#[derive(Debug)]",
      "struct ${1:MyStruct} {",
      "  ${2:value}: ${3:String},",
      "}",
      "\n"
    ]
  },
  "define Error/Result": {
    "prefix": "1u-error-dev",
    "description": "define Error/Result types for early dev.",
    "body": [
      "// Setup dynamic Error & Result type",
      "pub type Result<T> = core::result::Result<T, Error>;",
      "pub type Error = Box<dyn std::error::Error>; // For early dev.",
      "\n"
    ]
  },
  "custom error.rs": {
    "prefix": "1u-error-rs",
    "description": "custom Error boilerplate",
    "body": [
      "// Setup Result Type",
      "pub type Result<T> = core::result::Result<T, Error>;",
      "",
      "// Setup custom Error enum",
      "#[derive(Debug)]",
      "pub enum Error {",
      "\t${1:// TBC}",
      "}",
      "",
      "// Implement Display trait for Error",
      "impl core::fmt::Display for Error {",
      "\tfn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::result::Result<(), core::fmt::Error> {",
      "\t\twrite!(fmt, \"{self:?}\")",
      "\t}",
      "}",
      "",
      "// Implement std. Error trait for custom Error",
      "impl std::error::Error for Error {}",
      ""
    ]
  },
  "Err(err)": {
    "prefix": "1u-misc-err",
    "description": "Err(err)",
    "body": ["Err(${1:err})"]
  },
  "Err(Error::)": {
    "prefix": "1u-misc-err-custom",
    "description": "Err(Error::)",
    "body": ["Err(Error::${1:err})"]
  },
  "println!(\"{:?}\")": {
    "prefix": "1u-print-dbg",
    "description": "debug print a value",
    "body": ["println!(\"{:?}\", ${1:var});"]
  },
  "Result<T>": {
    "prefix": "1u-result",
    "description": "Result<T>",
    "body": ["Result<${1:T}>"]
  },
  "Some(Value)": {
    "prefix": "1u-some",
    "description": "Some(value)",
    "body": ["Some(${1:value})"]
  },
  "new vec!": {
    "prefix": "1u-vec!",
    "description": "Create a new vector with values",
    "body": ["let ${1:values} = vec![$2];"]
  },
  "new mut vector": {
    "prefix": "1u-vec-mut",
    "description": "Create a new mutable vector",
    "body": ["let mut ${1:values}: Vec<${2:String}> = Vec::new();"]
  }
}
